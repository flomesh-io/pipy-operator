apiVersion: flomesh.io/v1
kind: Proxy
metadata:
  name: pipy-standalone-008
spec:
  mode: Standalone
  tplMode: Raw
  replicas: 1
  image: flomesh/pipy:latest
  port: 6000
  config:
    config.cfg: |
      pipy
        pipeline :6000
          decode-http-request
            prefix = a
          script
            source = route.js
          proxy
            to = ${target}
          encode-http-response
            prefix = a

        pipeline 404
          hello
            message = No route\n

        pipeline sign
          script
            source = sign.js

        pipeline verify
          script
            source = verify.js

        pipeline encrypt
          script
            source = encrypt.js

        pipeline decrypt
          script
            source = decrypt.js
    decrypt.js: |
      import { KEY } from './keys.js';

      export default (output, context) => {
        let buffer = null;

        return (input) => {
          if (input instanceof Buffer) {
            buffer.push(input);

          } else if (input instanceof Event) {
            switch (input.type) {
              case 'messagestart':
                buffer = new Buffer();
                break;

              case 'messageend':
                const decipher = new crypto.Decipher('sm4-cbc', KEY, new Buffer(16));
                const out = decipher.update(new Buffer(buffer.toString(), 'base64'));
                out.push(decipher.final());
                output(new Event('messagestart'));
                output(out);
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    encrypt.js: |
      import { KEY } from './keys.js';

      export default (output, context) => {
        let buffer = null;

        return (input) => {
          if (input instanceof Buffer) {
            buffer.push(input);

          } else if (input instanceof Event) {
            switch (input.type) {
              case 'messagestart':
                buffer = new Buffer();
                break;

              case 'messageend':
                const cipher = new crypto.Cipher('sm4-cbc', KEY, new Buffer(16));
                const out = cipher.update(buffer);
                out.push(cipher.final());
                output(new Event('messagestart'));
                output(new Buffer(out.toString('base64') + '\n'));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    keys.js: |
      export const ID = '12345678';

      export const KEY = '0123456789abcdef';

      export const PUBLIC_KEY = `
      -----BEGIN PUBLIC KEY-----
      MFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAE+ffqzzp1v8DFujnfGnYlcr2DxyM9
      7xkiwqVPQcMSY+v8Jk4eV2PWjTm2Kd761e+3pIAPtdKxROcANDiz0VAMcQ==
      -----END PUBLIC KEY-----
      `;

      export const PRIVATE_KEY = `
      -----BEGIN EC PRIVATE KEY-----
      MHcCAQEEINdagaKS7t8B6pCfnoGBbAwKocf3rM2MUfOmqQ5XFj6poAoGCCqBHM9V
      AYItoUQDQgAE+ffqzzp1v8DFujnfGnYlcr2DxyM97xkiwqVPQcMSY+v8Jk4eV2PW
      jTm2Kd761e+3pIAPtdKxROcANDiz0VAMcQ==
      -----END EC PRIVATE KEY-----
      `;
    route.js: |
      const ROUTES = {
        '/sign' : 'sign',
        '/veri' : 'verify',
        '/enc'  : 'encrypt',
        '/dec'  : 'decrypt',
      };

      export default (output, context) => (
        input => {
          if (input instanceof Event &&
              input.type === 'messagestart'
          ) {
            const path = context.get('a.path');
            const target = ROUTES[path];
            if (target === undefined) {
              context.set('target', '404');
              context.set('a.status_code', '404');
              context.set('a.status', 'Not Found');
            } else {
              context.set('target', target);
              context.set('a.status_code', '200');
              context.set('a.status', 'OK');
            }
          }

          output(input);
        }
      );

    sign.js: |
      import { ID, PRIVATE_KEY } from './keys.js';

      export default (output, context) => {
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            digest.update(input);

          } else if (input instanceof Event) {
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;

              case 'messagestart':
                digest = new crypto.Sign('sm2-sm3', {
                  id: ID,
                  key: PRIVATE_KEY,
                });
                break;

              case 'messageend':
                const result = digest.final().toString('hex') + '\n';
                output(new Event('messagestart'));
                output(new Buffer(result));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }
    verify.js: |
      import { ID, PUBLIC_KEY } from './keys.js';

      export default (output, context) => {
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            digest.update(input);

          } else if (input instanceof Event) {
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;

              case 'messagestart':
                digest = new crypto.Verify('sm2-sm3', {
                  id: ID,
                  key: PUBLIC_KEY,
                });
                break;

              case 'messageend':
                let result;
                if (digest.final(new Buffer(context.get('a.request.sig'), 'hex'))) {
                  result = 'Verified\n';
                } else {
                  result = 'Not verified\n';
                }
                output(new Event('messagestart'));
                output(new Buffer(result));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }
