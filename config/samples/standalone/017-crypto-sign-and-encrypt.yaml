apiVersion: flomesh.io/v1
kind: Proxy
metadata:
  name: pipy-017
spec:
  mode: Standalone
  tplMode: Raw
  replicas: 1
  image: flomesh/pipy:latest
  port: 8080
  config:
    config.cfg: |
      pipeline 0.0.0.0:8080
          decode-http-request
              variable_protocol = http_protocol
              variable_method = http_method
              variable_path = http_path
              variable_headers = headers.*
          script
              source = /etc/pipy/sign-and-encrypt.js
      #        source = sign.js
      #        source = encrypt.js
          encode-http-request
              method = ${http_method}
              path = ${http_path}
              headers.content-type = ${headers.content-type}
          proxy
              to = 127.0.0.1:4001
          decode-http-response
          script
              source = /etc/pipy/decrypt-and-verify.js
      #        source = verify.js
      #        source = decrypt.js
          encode-http-response
              status = ${http_status}
              status_code = ${http_status_code}
              headers.Content-Type = application/json
      #
      # Echo服务用来模拟上游
      #
      pipeline 127.0.0.1:4001
          decode-http-request
              variable_protocol = http_protocol
              variable_headers = http_headers.*
          #print
          encode-http-response
              protocol = ${http_protocol}
              variable_connection = http_headers.connection
              variable_keep_alive = http_headers.keep-alive

    constants.js: |
      export const ID = '12345678';

      export const APP_SECRET = "appSecret";

      export const PUBLIC_KEY = `
      -----BEGIN PUBLIC KEY-----
      MFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAE+ffqzzp1v8DFujnfGnYlcr2DxyM9
      7xkiwqVPQcMSY+v8Jk4eV2PWjTm2Kd761e+3pIAPtdKxROcANDiz0VAMcQ==
      -----END PUBLIC KEY-----
      `;

      export const PRIVATE_KEY = `
      -----BEGIN EC PRIVATE KEY-----
      MHcCAQEEINdagaKS7t8B6pCfnoGBbAwKocf3rM2MUfOmqQ5XFj6poAoGCCqBHM9V
      AYItoUQDQgAE+ffqzzp1v8DFujnfGnYlcr2DxyM97xkiwqVPQcMSY+v8Jk4eV2PW
      jTm2Kd761e+3pIAPtdKxROcANDiz0VAMcQ==
      -----END EC PRIVATE KEY-----
      `;

    decrypt-and-verify.js: |
      import  { APP_SECRET, PUBLIC_KEY } from "./constants.js";

      export default (output, context) => {
        let buffer = null;
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            if (buffer) {
              buffer.push(input);
            }
          } else if (input instanceof Event) {
            let sig = context.get('headers.sig');
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;
              case 'messagestart':
                buffer = new Buffer();
                digest = new crypto.Verify('sm2-sha256', { key: PUBLIC_KEY });
                break;
              case 'messageend':
                const json = JSON.parse(buffer.toString());

                // Decrypt
                const key = new Buffer(json.appId, "hex");

                const buf = new Buffer(APP_SECRET);
                const cipher = new crypto.Cipher('sm4-ecb', key, new Buffer(16));
                let out = cipher.update(buf);
                out.push(cipher.final());
                const str = out.toString('hex');

                const key2 = new Buffer(str.substring(0, 32).toUpperCase(), "hex");
                const buf2 = new Buffer(json.encData, "hex");
                const decipher = new crypto.Decipher('sm4-ecb', key2, new Buffer(16));
                let out2 = decipher.update(buf2);
                out2.push(decipher.final());
                const str2 = out2.toString();

                json.data = JSON.parse(str2);
                delete json.encData;

                // Verify
                const excludes = new Set();
                excludes.add('signData');
                excludes.add('encData');
                excludes.add('extra');
                const keys = Object.keys(json).filter((key) => !excludes.has(key)).sort();

                const elements = [];
                for (let key of keys) {
                if ('data' === key) {
                elements.push(key + '=' + JSON.stringify(json[key]));
                } else {
                elements.push(key + '=' + json[key]);
                }
                }
                let str3 = elements.join("&");
                str3 = str3 + "&appSecret=" + APP_SECRET;

                digest.update(new Buffer(str3));

                const sig = json['signData'];
                if (!digest.final(new Buffer(sig, 'base64'))) {
                context.set('http_status', 'Unauthorized');
                context.set('http_status_code', 401);
                output(new Event('messagestart'));
                output(new Event('messageend'));
                break;
                }

                context.set('http_status', 'Ok');
                context.set('http_status_code', 200);

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    decrypt.js: |
      import  { APP_SECRET } from "./constants.js";

      export default (output, context) => {
        let buffer = null;

        return (input) => {
          if (input instanceof Buffer) {
            if (buffer) {
              buffer.push(input);
            }
          } else if (input instanceof Event) {
            let sig = context.get('headers.sig');
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;
              case 'messagestart':
                buffer = new Buffer();
                break;
              case 'messageend':
                const json = JSON.parse(buffer.toString());

                const key = new Buffer(json.appId, "hex");

                const buf = new Buffer(APP_SECRET);
                const cipher = new crypto.Cipher('sm4-ecb', key, new Buffer(16));
                let out = cipher.update(buf);
                out.push(cipher.final());
                const str = out.toString('hex');

                const key2 = new Buffer(str.substring(0, 32).toUpperCase(), "hex");
                const buf2 = new Buffer(json.encData, "hex");
                const decipher = new crypto.Decipher('sm4-ecb', key2, new Buffer(16));
                let out2 = decipher.update(buf2);
                out2.push(decipher.final());
                const str2 = out2.toString();

                json.data = JSON.parse(str2);
                delete json.encData;

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    encrypy.js: |
      import  { APP_SECRET } from "./constants.js";

      export default (output, context) => {
        let buffer = null;

        return (input) => {
          if (input instanceof Buffer) {
            if (buffer) {
              buffer.push(input);
            }
          } else if (input instanceof Event) {
            let sig = context.get('headers.sig');
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;
              case 'messagestart':
                buffer = new Buffer();
                break;
              case 'messageend':
                const json = JSON.parse(buffer.toString());

                const key = new Buffer(json.appId, "hex");

                const buf = new Buffer(APP_SECRET);
                const cipher = new crypto.Cipher('sm4-ecb', key, new Buffer(16));
                let out = cipher.update(buf);
                out.push(cipher.final());
                const str = out.toString('hex');

                const buf2 = new Buffer(JSON.stringify(json.data));
                const key2 = new Buffer(str.substring(0, 32).toUpperCase(), "hex");
                const cipher2 = new crypto.Cipher('sm4-ecb', key2, new Buffer(16));
                let out2 = cipher2.update(buf2);
                out2.push(cipher2.final());
                const str2 = out2.toString('hex').toUpperCase();

                json.encData = str2;
                delete json.data;

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    sign-and-encrypt.js: |
      import  { APP_SECRET, PRIVATE_KEY } from "./constants.js";

      let buf = null;

      export default (output, context) => {
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            buf.push(input);

          } else if (input instanceof Event) {
            let sig = context.get('headers.sig');
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;

              case 'messagestart':
                digest = new crypto.Sign('sm2-sha256', { key: PRIVATE_KEY });
                buf = new Buffer();
                break;
              case 'messageend':
                const json = JSON.parse(buf.toString());

                // Sign
                const excludes = new Set();
                excludes.add('signData');
                excludes.add('encData');
                excludes.add('extra');
                const keys = Object.keys(json).filter((key) => !excludes.has(key)).sort();

                const elements = [];
                for (let key of keys) {
                  if ('data' === key) {
                    elements.push(key + '=' + JSON.stringify(json[key]));
                  } else {
                    elements.push(key + '=' + json[key]);
                  }
                }
                let str = elements.join("&");
                str = str + "&appSecret=" + APP_SECRET;

                digest.update(new Buffer(str));
                const signData = digest.final().toString('base64');
                json.signData = signData;

                // Encrypt
                const key = new Buffer(json.appId, "hex");

                const buf2 = new Buffer(APP_SECRET);
                const cipher = new crypto.Cipher('sm4-ecb', key, new Buffer(16));
                let out = cipher.update(buf2);
                out.push(cipher.final());
                const str2 = out.toString('hex');

                const buf3 = new Buffer(JSON.stringify(json.data));
                const key2 = new Buffer(str2.substring(0, 32).toUpperCase(), "hex");
                const cipher2 = new crypto.Cipher('sm4-ecb', key2, new Buffer(16));
                let out2 = cipher2.update(buf3);
                out2.push(cipher2.final());
                const str3 = out2.toString('hex').toUpperCase();

                json.encData = str3;
                delete json.data;

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    sign.js: |
      import  { APP_SECRET, PRIVATE_KEY } from "./constants.js";

      let buf = null;

      export default (output, context) => {
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            buf.push(input);

          } else if (input instanceof Event) {
            let sig = context.get('headers.sig');
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;

              case 'messagestart':
                digest = new crypto.Sign('sm2-sha256', { key: PRIVATE_KEY });
                buf = new Buffer();
                break;
              case 'messageend':
                const json = JSON.parse(buf.toString());

                const excludes = new Set();
                excludes.add('signData');
                excludes.add('encData');
                excludes.add('extra');
                const keys = Object.keys(json).filter((key) => !excludes.has(key)).sort();

                const elements = [];
                for (let key of keys) {
                  if ('data' === key) {
                    elements.push(key + '=' + JSON.stringify(json[key]));
                  } else {
                    elements.push(key + '=' + json[key]);
                  }
                }
                let str = elements.join("&");
                str = str + "&appSecret=" + APP_SECRET;

                digest.update(new Buffer(str));
                const signData = digest.final().toString('base64');
                json.signData = signData;

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }

    verify.js: |
      import  { APP_SECRET, PUBLIC_KEY } from "./constants.js";

      let buf = null;

      export default (output, context) => {
        let digest = null;

        return (input) => {
          if (input instanceof Buffer) {
            buf.push(input);

          } else if (input instanceof Event) {
            switch (input.type) {
              case 'sessionstart':
              case 'sessionend':
                output(input);
                break;
              case 'messagestart':
                digest = new crypto.Verify('sm2-sha256', { key: PUBLIC_KEY });
                buf = new Buffer();
                break;
              case 'messageend':
                const json = JSON.parse(buf.toString());

                const excludes = new Set();
                excludes.add('signData');
                excludes.add('encData');
                excludes.add('extra');
                const keys = Object.keys(json).filter((key) => !excludes.has(key)).sort();

                const elements = [];
                for (let key of keys) {
                  if ('data' === key) {
                    elements.push(key + '=' + JSON.stringify(json[key]));
                  } else {
                    elements.push(key + '=' + json[key]);
                  }
                }
                let str = elements.join("&");
                str = str + "&appSecret=" + APP_SECRET;

                digest.update(new Buffer(str));

                const sig = json['signData'];
                if (!digest.final(new Buffer(sig, 'base64'))) {
                  context.set('http_status', 'Unauthorized');
                  context.set('http_status_code', 401);
                  output(new Event('messagestart'));
                  output(new Event('messageend'));
                  break;
                }

                context.set('http_status', 'Ok');
                context.set('http_status_code', 200);

                output(new Event('messagestart'));
                output(new Buffer(JSON.stringify(json)));
                output(new Event('messageend'));
                break;
            }
          }
        }
      }
